#!/usr/bin/env python3
"""
Medallion Generator

Creates a 3D model (for STL export) of a medallion of a given size (script parameter,
defaults to 5cm diameter). The medallion's thickness is 1/20 of its diameter.

The medallion has six copies of the leaf generated by `generate_leaf_stl.py` arranged
in a circle separated by 60 degrees angle. Each leaf is scaled down to fit within 60%
of the diameter of the medallion, and are placed so the leaf tips touch the medallion's
outer edge. In the center of the medallion, in the remaining space between the leaves,
is a large disc floret. The leaf model is simplified as it is scaled down to avoid
excessive amounts of polygons.
"""

import argparse
import numpy as np
from PIL import Image
import scipy.ndimage as ndimage
import trimesh
from generate_leaf_stl import load_and_process_image, enhance_veins, create_watertight_mesh
from generate_disc_floret_stl import create_disc_floret_mesh


def create_leaf_mesh(image_path='green-leaf.png'):
    """Generate a leaf mesh from the image."""
    height_map, alpha = load_and_process_image(image_path)
    enhanced_map = enhance_veins(height_map, alpha)
    leaf_mesh = create_watertight_mesh(
        enhanced_map,
        alpha,
        scale_xy=100.0,
        scale_z=3.5,
        base_thickness=1.0
    )
    return leaf_mesh


def simplify_mesh(mesh, target_faces):
    """Simplify mesh to reduce polygon count using pyfqmr."""
    if len(mesh.faces) > target_faces:
        try:
            import pyfqmr

            # Create a mesh simplifier
            mesh_simplifier = pyfqmr.Simplify()
            mesh_simplifier.setMesh(mesh.vertices, mesh.faces)
            mesh_simplifier.simplify_mesh(target_count=target_faces, aggressiveness=7, preserve_border=True)

            # Get simplified mesh
            simplified_vertices, simplified_faces, simplified_normals = mesh_simplifier.getMesh()

            # Create new trimesh object
            simplified_mesh = trimesh.Trimesh(vertices=simplified_vertices, faces=simplified_faces)
            print(f"  Simplified from {len(mesh.faces)} to {len(simplified_mesh.faces)} faces")
            return simplified_mesh

        except (ImportError, Exception) as e:
            print(f"  Note: Mesh simplification not available ({e})")
            print(f"  Continuing with full resolution mesh ({len(mesh.faces)} faces)")
    return mesh




def create_medallion_base(diameter, thickness, resolution=64,
                          num_ridges=3, ridge_amplitude=0.3,
                          ridge_inner_ratio=0.45, ridge_outer_ratio=0.85,
                          convexity_height=None):
    """
    Create the base disc of the medallion with rounded upper outer corner and concentric ridges.

    Args:
        diameter: Diameter of the medallion
        thickness: Thickness of the medallion
        resolution: Angular resolution (segments around the circle)
        num_ridges: Number of concentric ridges (default 3)
        ridge_amplitude: Height of ridges as fraction of thickness (default 0.3)
        ridge_inner_ratio: Inner radius for ridges as fraction of medallion radius (default 0.15)
        ridge_outer_ratio: Outer radius for ridges as fraction of medallion radius (default 0.85)
        convexity_height: Additional height at center for convex dome effect (default: 3% of diameter)
    """
    radius = diameter / 2
    corner_radius = diameter * 0.01  # 1% of diameter

    # Set default convexity if not provided
    if convexity_height is None:
        convexity_height = diameter * 0.03  # 3% of diameter for subtle dome

    vertices = []
    faces = []

    # Define layers
    angular_segments = resolution
    corner_segments = 6  # Segments for the rounded corner arc
    radial_segments = 16  # Number of radial rings on top surface for smooth ridges

    # Inner radius and height (where rounding starts)
    inner_radius = radius - corner_radius
    inner_height = thickness - corner_radius

    # Helper function to calculate convex dome height based on radial position
    def get_convex_height(r):
        """Calculate dome height based on radius using parabolic curve."""
        # Parabolic curve: height decreases from center to edge
        # At center (r=0): full convexity_height
        # At edge (r=radius): 0
        normalized_r = min(r / radius, 1.0)  # Normalize to [0, 1]
        return convexity_height * (1.0 - normalized_r**2)

    # Helper function to calculate ridge height modulation
    def get_ridge_height(r):
        """Calculate height modulation based on radius for ridge effect."""
        # Only apply ridges in the specified radial range
        ridge_inner_r = radius * ridge_inner_ratio
        ridge_outer_r = radius * ridge_outer_ratio

        if r < ridge_inner_r or r > ridge_outer_r:
            return 0.0

        # Normalize radius to [0, 1] within ridge zone
        normalized_r = (r - ridge_inner_r) / (ridge_outer_r - ridge_inner_r)

        # Create smooth rounded ridges using absolute value of sine wave
        # This creates smooth humps (like the top of a sine wave repeated)
        wave = np.abs(np.sin(normalized_r * num_ridges * np.pi))

        # Apply amplitude
        return wave * ridge_amplitude * thickness

    # Bottom center
    vertices.append([0, 0, 0])
    bottom_center_idx = 0

    # Top center with ridge modulation and convexity
    center_ridge_height = get_ridge_height(0)
    center_convex_height = get_convex_height(0)
    vertices.append([0, 0, inner_height + center_ridge_height + center_convex_height])
    top_center_idx = 1

    # Create bottom ring vertices (outer wall base)
    for seg in range(angular_segments):
        angle = 2 * np.pi * seg / angular_segments
        x = radius * np.cos(angle)
        y = radius * np.sin(angle)
        vertices.append([x, y, 0])

    # Create outer wall top ring (where vertical wall ends and corner starts)
    for seg in range(angular_segments):
        angle = 2 * np.pi * seg / angular_segments
        x = radius * np.cos(angle)
        y = radius * np.sin(angle)
        vertices.append([x, y, inner_height])

    # Create multiple radial rings on the top surface for smooth ridges
    top_rings_start = len(vertices)
    for ring_idx in range(radial_segments):
        # Radius for this ring (from near-center to inner_radius)
        ring_ratio = (ring_idx + 1) / radial_segments
        ring_radius = inner_radius * ring_ratio

        for seg in range(angular_segments):
            angle = 2 * np.pi * seg / angular_segments
            x = ring_radius * np.cos(angle)
            y = ring_radius * np.sin(angle)

            # Calculate base height with ridge modulation and convexity
            base_z = thickness
            ridge_height = get_ridge_height(ring_radius)
            convex_height = get_convex_height(ring_radius)
            z = base_z + ridge_height + convex_height

            vertices.append([x, y, z])

    # Create rounded corner vertices (quarter-circle arc)
    for corner_step in range(corner_segments - 1):
        # Angle along the corner arc (skip 0째 and 90째 as they're already created)
        corner_angle = (np.pi / 2) * (corner_step + 1) / corner_segments

        # Arc center is at (inner_radius, inner_height)
        # Arc goes from (inner_radius, thickness) at 0째 to (radius, inner_height) at 90째
        r = inner_radius + corner_radius * np.sin(corner_angle)
        base_z = inner_height + corner_radius * np.cos(corner_angle)

        # Apply convexity to corner vertices
        convex_height = get_convex_height(r)
        z = base_z + convex_height

        for seg in range(angular_segments):
            angle = 2 * np.pi * seg / angular_segments
            x = r * np.cos(angle)
            y = r * np.sin(angle)
            vertices.append([x, y, z])

    # Ring indices
    bottom_ring_start = 2
    outer_wall_top_ring = 2 + angular_segments
    # top_rings_start was already set above
    inner_top_ring = top_rings_start + (radial_segments - 1) * angular_segments  # Outermost radial ring
    first_corner_ring = top_rings_start + radial_segments * angular_segments

    # Create faces
    # Bottom cap - from center to bottom ring
    for seg in range(angular_segments):
        next_seg = (seg + 1) % angular_segments
        v1 = bottom_ring_start + seg
        v2 = bottom_ring_start + next_seg
        faces.append([bottom_center_idx, v2, v1])

    # Top surface - connect center to first radial ring
    first_ring_start = top_rings_start
    for seg in range(angular_segments):
        next_seg = (seg + 1) % angular_segments
        v1 = first_ring_start + seg
        v2 = first_ring_start + next_seg
        faces.append([top_center_idx, v1, v2])

    # Top surface - connect radial rings to each other
    for ring_idx in range(radial_segments - 1):
        ring1_start = top_rings_start + ring_idx * angular_segments
        ring2_start = top_rings_start + (ring_idx + 1) * angular_segments

        for seg in range(angular_segments):
            next_seg = (seg + 1) % angular_segments
            v1 = ring1_start + seg
            v2 = ring1_start + next_seg
            v3 = ring2_start + seg
            v4 = ring2_start + next_seg

            faces.append([v1, v2, v4])
            faces.append([v1, v4, v3])

    # Vertical outer wall - from bottom ring to outer wall top
    for seg in range(angular_segments):
        next_seg = (seg + 1) % angular_segments
        v1 = bottom_ring_start + seg
        v2 = bottom_ring_start + next_seg
        v3 = outer_wall_top_ring + seg
        v4 = outer_wall_top_ring + next_seg

        faces.append([v1, v2, v4])
        faces.append([v1, v4, v3])

    # Rounded corner surface
    num_corner_rings = corner_segments - 1
    for corner_step in range(num_corner_rings + 1):
        if corner_step == 0:
            # Connect inner top ring to first corner ring
            ring1_start = inner_top_ring
            ring2_start = first_corner_ring
        elif corner_step == num_corner_rings:
            # Connect last corner ring to outer wall top
            ring1_start = first_corner_ring + (corner_step - 1) * angular_segments
            ring2_start = outer_wall_top_ring
        else:
            # Connect between corner rings
            ring1_start = first_corner_ring + (corner_step - 1) * angular_segments
            ring2_start = first_corner_ring + corner_step * angular_segments

        for seg in range(angular_segments):
            next_seg = (seg + 1) % angular_segments
            v1 = ring1_start + seg
            v2 = ring1_start + next_seg
            v3 = ring2_start + seg
            v4 = ring2_start + next_seg

            faces.append([v1, v2, v4])
            faces.append([v1, v4, v3])

    vertices = np.array(vertices, dtype=np.float64)
    faces = np.array(faces, dtype=np.int32)

    mesh = trimesh.Trimesh(vertices=vertices, faces=faces)

    return mesh


def create_medallion(diameter_mm=50.0, image_path='green-leaf.png',
                     num_ridges=3, ridge_amplitude=0.3,
                     ridge_inner_ratio=0.15, ridge_outer_ratio=0.85,
                     leaf_thickness_scale=1.5, convexity_height=None):
    """
    Create a medallion with six leaves arranged in a circle.

    Args:
        diameter_mm: Diameter of the medallion in millimeters (default 50mm = 5cm)
        image_path: Path to the leaf image
        num_ridges: Number of concentric ridges on base (default 3)
        ridge_amplitude: Height of ridges as fraction of thickness (default 0.3)
        ridge_inner_ratio: Inner radius for ridges as fraction of medallion radius (default 0.15)
        ridge_outer_ratio: Outer radius for ridges as fraction of medallion radius (default 0.85)
        leaf_thickness_scale: Scale factor for leaf z-dimension thickness (default 1.5 = 50% thicker)
        convexity_height: Additional height at center for convex dome effect (default: 3% of diameter)

    Returns:
        A trimesh object representing the complete medallion
    """
    # Calculate dimensions
    thickness = diameter_mm / 20.0
    radius = diameter_mm / 2.0

    # Set default convexity if not provided
    if convexity_height is None:
        convexity_height = diameter_mm * 0.03  # 3% of diameter for subtle dome

    print(f"Creating medallion: {diameter_mm}mm diameter, {thickness}mm thickness")
    print(f"Ridge configuration: {num_ridges} ridges, amplitude={ridge_amplitude}")
    print(f"Convexity: {convexity_height:.2f}mm dome height at center")

    # Create base disc with ridges and convexity
    print("Creating base disc with concentric ridges and convex surface...")
    base = create_medallion_base(diameter_mm, thickness,
                                  num_ridges=num_ridges,
                                  ridge_amplitude=ridge_amplitude,
                                  ridge_inner_ratio=ridge_inner_ratio,
                                  ridge_outer_ratio=ridge_outer_ratio,
                                  convexity_height=convexity_height)

    all_meshes = [base]
    generate_leaves = True
    if generate_leaves:
        # Generate leaf mesh
        print("Generating leaf mesh...")
        leaf_mesh = create_leaf_mesh(image_path)

        # Get leaf bounds to determine scaling
        leaf_bounds = leaf_mesh.bounds
        leaf_width = leaf_bounds[1][0] - leaf_bounds[0][0]
        leaf_height = leaf_bounds[1][1] - leaf_bounds[0][1]
        leaf_depth = leaf_bounds[1][2] - leaf_bounds[0][2]

        print(f"Original leaf size: {leaf_width:.2f} x {leaf_height:.2f} x {leaf_depth:.2f} mm")

        # Scale leaf to fit within 60% of medallion radius
        target_leaf_size = diameter_mm * 0.7 * 0.5
        current_max_dimension = max(leaf_width, leaf_height)
        scale_factor = target_leaf_size / current_max_dimension

        print(f"Scaling leaf by factor: {scale_factor:.3f}")
        leaf_mesh.apply_scale(scale_factor)

        # Apply additional thickness scaling in z-direction to rise above ridges
        if leaf_thickness_scale != 1.0:
            print(f"Scaling leaf thickness by {leaf_thickness_scale:.2f}x to rise above ridges")
            leaf_mesh.apply_scale([1.0, 1.0, leaf_thickness_scale])

        # Simplify the leaf mesh to reduce polygon count
        # Target approximately 500-1000 faces per leaf (reasonable detail)
        target_faces = min(1000, len(leaf_mesh.faces) // 2)
        print(f"Simplifying leaf from {len(leaf_mesh.faces)} to ~{target_faces} faces...")
        leaf_mesh = simplify_mesh(leaf_mesh, target_faces)
        print(f"Simplified leaf has {len(leaf_mesh.faces)} faces")

        # Update bounds after scaling
        leaf_bounds = leaf_mesh.bounds
        leaf_width_scaled = leaf_bounds[1][0] - leaf_bounds[0][0]
        leaf_height_scaled = leaf_bounds[1][1] - leaf_bounds[0][1]

        # Calculate distance from center to place leaves
        # We want the tip (furthest point) to touch the outer edge
        max_leaf_extent = max(leaf_width_scaled, leaf_height_scaled) / 2
        placement_radius = (radius * 0.95) - max_leaf_extent

        # Helper function to calculate surface height at a given radius (matching the base)
        def get_surface_height_at_radius(r):
            """Calculate the surface height at a given radius, including convexity and ridges."""
            # Base thickness
            base_height = thickness

            # Convexity (parabolic dome)
            normalized_r = min(r / radius, 1.0)
            convex_h = convexity_height * (1.0 - normalized_r**2)

            # Ridge height (matching the base logic)
            ridge_inner_r = radius * ridge_inner_ratio
            ridge_outer_r = radius * ridge_outer_ratio
            ridge_h = 0.0
            if ridge_inner_r <= r <= ridge_outer_r:
                normalized_ridge_r = (r - ridge_inner_r) / (ridge_outer_r - ridge_inner_r)
                wave = np.abs(np.sin(normalized_ridge_r * num_ridges * np.pi))
                ridge_h = wave * ridge_amplitude * thickness

            return base_height + convex_h + ridge_h

        # Calculate the offset needed to place leaf bottom flush with medallion top at placement radius
        # The leaf has negative Z values (bottom at -base_thickness), so we need to
        # translate it up to align with the curved surface
        surface_height_at_leaf = get_surface_height_at_radius(placement_radius)
        leaf_z_offset = surface_height_at_leaf - leaf_bounds[0][2]

        # Create six leaf copies arranged in a circle
        print("Arranging leaves in circle...")
        leaves = []
        for i in range(6):
            angle = i * 60  # degrees
            angle_rad = np.radians(angle)

            # Copy the leaf
            leaf_copy = leaf_mesh.copy()

            # Rotate leaf to point outward
            rotation_matrix = trimesh.transformations.rotation_matrix(
                angle_rad + np.radians(90), [0, 0, 1]
            )
            leaf_copy.apply_transform(rotation_matrix)

            # Translate to position around the circle
            x = placement_radius * np.cos(angle_rad)
            y = placement_radius * np.sin(angle_rad)
            leaf_copy.apply_translation([x, y, leaf_z_offset])

            leaves.append(leaf_copy)

        # Create center disc floret
        # The floret should fill the space between leaves and sit on the curved surface
        floret_diameter = placement_radius * 0.6 * 2  # Convert radius to diameter

        # The floret is at the center, so it should be positioned at the peak of the dome
        center_surface_height = get_surface_height_at_radius(0)

        print(f"Creating center disc floret (diameter: {floret_diameter:.2f}mm)...")
        floret = create_disc_floret_mesh(
            diameter_mm=floret_diameter,
            base_height=center_surface_height,  # Use the curved surface height at center
            floret_density=1.0
        )

        # Combine all meshes
        all_meshes.append(floret)
        all_meshes.extend(leaves)

    print("Combining all components...")
    medallion = trimesh.util.concatenate(all_meshes)

    print(f"Final medallion: {len(medallion.vertices)} vertices, {len(medallion.faces)} faces")
    print(f"Watertight: {medallion.is_watertight}")

    return medallion


def main():
    parser = argparse.ArgumentParser(
        description='Generate a medallion with six leaves arranged in a circle'
    )
    parser.add_argument(
        '--diameter',
        type=float,
        default=50.0,
        help='Diameter of the medallion in millimeters (default: 50mm = 5cm)'
    )
    parser.add_argument(
        '--image',
        type=str,
        default='green-leaf.png',
        help='Path to leaf image (default: green-leaf.png)'
    )
    parser.add_argument(
        '--output',
        type=str,
        default='medallion.stl',
        help='Output STL file (default: medallion.stl)'
    )
    parser.add_argument(
        '--num-ridges',
        type=int,
        default=3,
        help='Number of concentric ridges on the base (default: 3)'
    )
    parser.add_argument(
        '--ridge-amplitude',
        type=float,
        default=0.3,
        help='Height of ridges as fraction of medallion thickness (default: 0.3)'
    )
    parser.add_argument(
        '--ridge-inner-ratio',
        type=float,
        default=0.15,
        help='Inner radius for ridges as fraction of medallion radius (default: 0.15)'
    )
    parser.add_argument(
        '--ridge-outer-ratio',
        type=float,
        default=0.85,
        help='Outer radius for ridges as fraction of medallion radius (default: 0.85)'
    )
    parser.add_argument(
        '--leaf-thickness-scale',
        type=float,
        default=1.5,
        help='Scale factor for leaf z-dimension thickness (default: 1.5)'
    )
    parser.add_argument(
        '--convexity-height',
        type=float,
        default=None,
        help='Additional height at center for convex dome effect in mm (default: 3%% of diameter)'
    )

    args = parser.parse_args()

    # Create the medallion
    medallion = create_medallion(
        args.diameter,
        args.image,
        num_ridges=args.num_ridges,
        ridge_amplitude=args.ridge_amplitude,
        ridge_inner_ratio=args.ridge_inner_ratio,
        ridge_outer_ratio=args.ridge_outer_ratio,
        leaf_thickness_scale=args.leaf_thickness_scale,
        convexity_height=args.convexity_height
    )

    # Export to STL
    print(f"Exporting to {args.output}...")
    medallion.export(args.output)

    print("Done!")


if __name__ == '__main__':
    main()
