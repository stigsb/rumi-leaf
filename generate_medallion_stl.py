#!/usr/bin/env python3
"""
Medallion Generator

Creates a 3D model (for STL export) of a medallion of a given size (script parameter,
defaults to 5cm diameter). The medallion's thickness is 1/20 of its diameter.

The medallion has six copies of the leaf generated by `generate_leaf_stl.py` arranged
in a circle separated by 60 degrees angle. Each leaf is scaled down to fit within 60%
of the diameter of the medallion, and are placed so the leaf tips touch the medallion's
outer edge. In the center of the medallion, in the remaining space between the leaves,
is a large disc floret. The leaf model is simplified as it is scaled down to avoid
excessive amounts of polygons.
"""

import argparse
import numpy as np
from PIL import Image
import scipy.ndimage as ndimage
import trimesh
from generate_leaf_stl import load_and_process_image, enhance_veins, create_watertight_mesh
from generate_disc_floret_stl import create_disc_floret_mesh


def create_leaf_mesh(image_path='green-leaf.png'):
    """Generate a leaf mesh from the image."""
    height_map, alpha = load_and_process_image(image_path)
    enhanced_map = enhance_veins(height_map, alpha)
    leaf_mesh = create_watertight_mesh(
        enhanced_map,
        alpha,
        scale_xy=100.0,
        scale_z=3.5,
        base_thickness=1.0
    )
    return leaf_mesh


def simplify_mesh(mesh, target_faces):
    """Simplify mesh to reduce polygon count using pyfqmr."""
    if len(mesh.faces) > target_faces:
        try:
            import pyfqmr

            # Create a mesh simplifier
            mesh_simplifier = pyfqmr.Simplify()
            mesh_simplifier.setMesh(mesh.vertices, mesh.faces)
            mesh_simplifier.simplify_mesh(target_count=target_faces, aggressiveness=7, preserve_border=True)

            # Get simplified mesh
            simplified_vertices, simplified_faces, simplified_normals = mesh_simplifier.getMesh()

            # Create new trimesh object
            simplified_mesh = trimesh.Trimesh(vertices=simplified_vertices, faces=simplified_faces)
            print(f"  Simplified from {len(mesh.faces)} to {len(simplified_mesh.faces)} faces")
            return simplified_mesh

        except (ImportError, Exception) as e:
            print(f"  Note: Mesh simplification not available ({e})")
            print(f"  Continuing with full resolution mesh ({len(mesh.faces)} faces)")
    return mesh




def create_medallion_base(diameter, thickness, resolution=64):
    """Create the base disc of the medallion with rounded upper outer corner."""
    radius = diameter / 2
    corner_radius = diameter * 0.01  # 1% of diameter

    vertices = []
    faces = []

    # Define layers
    angular_segments = resolution
    corner_segments = 6  # Segments for the rounded corner arc

    # Inner radius and height (where rounding starts)
    inner_radius = radius - corner_radius
    inner_height = thickness - corner_radius

    # Bottom center
    vertices.append([0, 0, 0])
    bottom_center_idx = 0

    # Top center (at inner height since top surface is flat until corner)
    vertices.append([0, 0, inner_height])
    top_center_idx = 1

    # Create bottom ring vertices (outer wall base)
    for seg in range(angular_segments):
        angle = 2 * np.pi * seg / angular_segments
        x = radius * np.cos(angle)
        y = radius * np.sin(angle)
        vertices.append([x, y, 0])

    # Create outer wall top ring (where vertical wall ends and corner starts)
    for seg in range(angular_segments):
        angle = 2 * np.pi * seg / angular_segments
        x = radius * np.cos(angle)
        y = radius * np.sin(angle)
        vertices.append([x, y, inner_height])

    # Create inner top ring (where flat top surface ends and corner starts)
    for seg in range(angular_segments):
        angle = 2 * np.pi * seg / angular_segments
        x = inner_radius * np.cos(angle)
        y = inner_radius * np.sin(angle)
        vertices.append([x, y, thickness])

    # Create rounded corner vertices (quarter-circle arc)
    for corner_step in range(corner_segments - 1):
        # Angle along the corner arc (skip 0째 and 90째 as they're already created)
        corner_angle = (np.pi / 2) * (corner_step + 1) / corner_segments

        # Arc center is at (inner_radius, inner_height)
        # Arc goes from (inner_radius, thickness) at 0째 to (radius, inner_height) at 90째
        r = inner_radius + corner_radius * np.sin(corner_angle)
        z = inner_height + corner_radius * np.cos(corner_angle)

        for seg in range(angular_segments):
            angle = 2 * np.pi * seg / angular_segments
            x = r * np.cos(angle)
            y = r * np.sin(angle)
            vertices.append([x, y, z])

    # Ring indices
    bottom_ring_start = 2
    outer_wall_top_ring = 2 + angular_segments
    inner_top_ring = 2 + 2 * angular_segments
    first_corner_ring = 2 + 3 * angular_segments

    # Create faces
    # Bottom cap - from center to bottom ring
    for seg in range(angular_segments):
        next_seg = (seg + 1) % angular_segments
        v1 = bottom_ring_start + seg
        v2 = bottom_ring_start + next_seg
        faces.append([bottom_center_idx, v2, v1])

    # Top cap - from center to inner top ring
    for seg in range(angular_segments):
        next_seg = (seg + 1) % angular_segments
        v1 = inner_top_ring + seg
        v2 = inner_top_ring + next_seg
        faces.append([top_center_idx, v1, v2])

    # Vertical outer wall - from bottom ring to outer wall top
    for seg in range(angular_segments):
        next_seg = (seg + 1) % angular_segments
        v1 = bottom_ring_start + seg
        v2 = bottom_ring_start + next_seg
        v3 = outer_wall_top_ring + seg
        v4 = outer_wall_top_ring + next_seg

        faces.append([v1, v2, v4])
        faces.append([v1, v4, v3])

    # Rounded corner surface
    num_corner_rings = corner_segments - 1
    for corner_step in range(num_corner_rings + 1):
        if corner_step == 0:
            # Connect inner top ring to first corner ring
            ring1_start = inner_top_ring
            ring2_start = first_corner_ring
        elif corner_step == num_corner_rings:
            # Connect last corner ring to outer wall top
            ring1_start = first_corner_ring + (corner_step - 1) * angular_segments
            ring2_start = outer_wall_top_ring
        else:
            # Connect between corner rings
            ring1_start = first_corner_ring + (corner_step - 1) * angular_segments
            ring2_start = first_corner_ring + corner_step * angular_segments

        for seg in range(angular_segments):
            next_seg = (seg + 1) % angular_segments
            v1 = ring1_start + seg
            v2 = ring1_start + next_seg
            v3 = ring2_start + seg
            v4 = ring2_start + next_seg

            faces.append([v1, v2, v4])
            faces.append([v1, v4, v3])

    vertices = np.array(vertices, dtype=np.float64)
    faces = np.array(faces, dtype=np.int32)

    mesh = trimesh.Trimesh(vertices=vertices, faces=faces)

    return mesh


def create_medallion(diameter_mm=50.0, image_path='green-leaf.png'):
    """
    Create a medallion with six leaves arranged in a circle.

    Args:
        diameter_mm: Diameter of the medallion in millimeters (default 50mm = 5cm)
        image_path: Path to the leaf image

    Returns:
        A trimesh object representing the complete medallion
    """
    # Calculate dimensions
    thickness = diameter_mm / 20.0
    radius = diameter_mm / 2.0

    print(f"Creating medallion: {diameter_mm}mm diameter, {thickness}mm thickness")

    # Create base disc
    print("Creating base disc...")
    base = create_medallion_base(diameter_mm, thickness)

    # Generate leaf mesh
    print("Generating leaf mesh...")
    leaf_mesh = create_leaf_mesh(image_path)

    # Get leaf bounds to determine scaling
    leaf_bounds = leaf_mesh.bounds
    leaf_width = leaf_bounds[1][0] - leaf_bounds[0][0]
    leaf_height = leaf_bounds[1][1] - leaf_bounds[0][1]
    leaf_depth = leaf_bounds[1][2] - leaf_bounds[0][2]

    print(f"Original leaf size: {leaf_width:.2f} x {leaf_height:.2f} x {leaf_depth:.2f} mm")

    # Scale leaf to fit within 60% of medallion radius
    target_leaf_size = diameter_mm * 0.7 * 0.5
    current_max_dimension = max(leaf_width, leaf_height)
    scale_factor = target_leaf_size / current_max_dimension

    print(f"Scaling leaf by factor: {scale_factor:.3f}")
    leaf_mesh.apply_scale(scale_factor)

    # Simplify the leaf mesh to reduce polygon count
    # Target approximately 500-1000 faces per leaf (reasonable detail)
    target_faces = min(1000, len(leaf_mesh.faces) // 2)
    print(f"Simplifying leaf from {len(leaf_mesh.faces)} to ~{target_faces} faces...")
    leaf_mesh = simplify_mesh(leaf_mesh, target_faces)
    print(f"Simplified leaf has {len(leaf_mesh.faces)} faces")

    # Update bounds after scaling
    leaf_bounds = leaf_mesh.bounds
    leaf_width_scaled = leaf_bounds[1][0] - leaf_bounds[0][0]
    leaf_height_scaled = leaf_bounds[1][1] - leaf_bounds[0][1]

    # Calculate distance from center to place leaves
    # We want the tip (furthest point) to touch the outer edge
    max_leaf_extent = max(leaf_width_scaled, leaf_height_scaled) / 2
    placement_radius = (radius * 0.95) - max_leaf_extent

    # Calculate the offset needed to place leaf bottom flush with medallion top
    # The leaf has negative Z values (bottom at -base_thickness), so we need to
    # translate it up by (thickness - leaf_bounds[0][2]) to make bottom align with top
    leaf_z_offset = thickness - leaf_bounds[0][2]

    # Create six leaf copies arranged in a circle
    print("Arranging leaves in circle...")
    leaves = []
    for i in range(6):
        angle = i * 60  # degrees
        angle_rad = np.radians(angle)

        # Copy the leaf
        leaf_copy = leaf_mesh.copy()

        # Rotate leaf to point outward
        rotation_matrix = trimesh.transformations.rotation_matrix(
            angle_rad + np.radians(90), [0, 0, 1]
        )
        leaf_copy.apply_transform(rotation_matrix)

        # Translate to position around the circle
        x = placement_radius * np.cos(angle_rad)
        y = placement_radius * np.sin(angle_rad)
        leaf_copy.apply_translation([x, y, leaf_z_offset])

        leaves.append(leaf_copy)

    # Create center disc floret
    # The floret should fill the space between leaves
    floret_diameter = placement_radius * 0.6 * 2  # Convert radius to diameter
    print(f"Creating center disc floret (diameter: {floret_diameter:.2f}mm)...")
    floret = create_disc_floret_mesh(
        diameter_mm=floret_diameter,
        base_height=thickness,
        floret_density=1.0
    )

    # Combine all meshes
    print("Combining all components...")
    all_meshes = [base, floret] + leaves
    medallion = trimesh.util.concatenate(all_meshes)

    print(f"Final medallion: {len(medallion.vertices)} vertices, {len(medallion.faces)} faces")
    print(f"Watertight: {medallion.is_watertight}")

    return medallion


def main():
    parser = argparse.ArgumentParser(
        description='Generate a medallion with six leaves arranged in a circle'
    )
    parser.add_argument(
        '--diameter',
        type=float,
        default=50.0,
        help='Diameter of the medallion in millimeters (default: 50mm = 5cm)'
    )
    parser.add_argument(
        '--image',
        type=str,
        default='green-leaf.png',
        help='Path to leaf image (default: green-leaf.png)'
    )
    parser.add_argument(
        '--output',
        type=str,
        default='medallion.stl',
        help='Output STL file (default: medallion.stl)'
    )

    args = parser.parse_args()

    # Create the medallion
    medallion = create_medallion(args.diameter, args.image)

    # Export to STL
    print(f"Exporting to {args.output}...")
    medallion.export(args.output)

    print("Done!")


if __name__ == '__main__':
    main()
